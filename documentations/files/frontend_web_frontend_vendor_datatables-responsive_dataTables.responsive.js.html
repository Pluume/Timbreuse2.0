<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>frontend\web_frontend\vendor\datatables-responsive\dataTables.responsive.js - Timbreuse</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Timbreuse" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/client.html">client</a></li>
                                <li><a href="../classes/config.html">config</a></li>
                                <li><a href="../classes/csv.html">csv</a></li>
                                <li><a href="../classes/DataTable.Api.html">DataTable.Api</a></li>
                                <li><a href="../classes/db.html">db</a></li>
                                <li><a href="../classes/frontendHandle.html">frontendHandle</a></li>
                                <li><a href="../classes/frontendUtil.html">frontendUtil</a></li>
                                <li><a href="../classes/holidays.html">holidays</a></li>
                                <li><a href="../classes/informations.html">informations</a></li>
                                <li><a href="../classes/leavereq.html">leavereq</a></li>
                                <li><a href="../classes/log.html">log</a></li>
                                <li><a href="../classes/login.html">login</a></li>
                                <li><a href="../classes/math.html">math</a></li>
                                <li><a href="../classes/pages.html">pages</a></li>
                                <li><a href="../classes/server.html">server</a></li>
                                <li><a href="../classes/server_methods.html">server_methods</a></li>
                                <li><a href="../classes/slave.html">slave</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/client.html">client</a></li>
                                <li><a href="../modules/config.html">config</a></li>
                                <li><a href="../modules/csv.html">csv</a></li>
                                <li><a href="../modules/db.html">db</a></li>
                                <li><a href="../modules/frontendHandle.html">frontendHandle</a></li>
                                <li><a href="../modules/frontendUtil.html">frontendUtil</a></li>
                                <li><a href="../modules/holidays.html">holidays</a></li>
                                <li><a href="../modules/informations.html">informations</a></li>
                                <li><a href="../modules/leavereq.html">leavereq</a></li>
                                <li><a href="../modules/log.html">log</a></li>
                                <li><a href="../modules/login.html">login</a></li>
                                <li><a href="../modules/main.html">main</a></li>
                                <li><a href="../modules/math.html">math</a></li>
                                <li><a href="../modules/pages.html">pages</a></li>
                                <li><a href="../modules/request.html">request</a></li>
                                <li><a href="../modules/server.html">server</a></li>
                                <li><a href="../modules/server_methods.html">server_methods</a></li>
                                <li><a href="../modules/slave.html">slave</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: frontend\web_frontend\vendor\datatables-responsive\dataTables.responsive.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! Responsive 1.0.6
 * 2014-2015 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     Responsive
 * @description Responsive tables plug-in for DataTables
 * @version     1.0.6
 * @file        dataTables.responsive.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2014-2015 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function(window, document, undefined) {


var factory = function( $, DataTable ) {
&quot;use strict&quot;;

/**
 * Responsive is a plug-in for the DataTables library that makes use of
 * DataTables&#x27; ability to change the visibility of columns, changing the
 * visibility of columns so the displayed columns fit into the table container.
 * The end result is that complex tables will be dynamically adjusted to fit
 * into the viewport, be it on a desktop, tablet or mobile browser.
 *
 * Responsive for DataTables has two modes of operation, which can used
 * individually or combined:
 *
 * * Class name based control - columns assigned class names that match the
 *   breakpoint logic can be shown / hidden as required for each breakpoint.
 * * Automatic control - columns are automatically hidden when there is no
 *   room left to display them. Columns removed from the right.
 *
 * In additional to column visibility control, Responsive also has built into
 * options to use DataTables&#x27; child row display to show / hide the information
 * from the table that has been hidden. There are also two modes of operation
 * for this child row display:
 *
 * * Inline - when the control element that the user can use to show / hide
 *   child rows is displayed inside the first column of the table.
 * * Column - where a whole column is dedicated to be the show / hide control.
 *
 * Initialisation of Responsive is performed by:
 *
 * * Adding the class &#x60;responsive&#x60; or &#x60;dt-responsive&#x60; to the table. In this case
 *   Responsive will automatically be initialised with the default configuration
 *   options when the DataTable is created.
 * * Using the &#x60;responsive&#x60; option in the DataTables configuration options. This
 *   can also be used to specify the configuration options, or simply set to
 *   &#x60;true&#x60; to use the defaults.
 *
 *  @param {object} settings DataTables settings object for the host table
 *  @param {object} [opts] Configuration options
 *  @requires jQuery 1.7+
 *  @requires DataTables 1.10.1+
 *
 *  @example
 *      $(&#x27;#example&#x27;).DataTable( {
 *        responsive: true
 *      } );
 *    } );
 */
var Responsive = function ( settings, opts ) {
	// Sanity check that we are using DataTables 1.10 or newer
	if ( ! DataTable.versionCheck || ! DataTable.versionCheck( &#x27;1.10.1&#x27; ) ) {
		throw &#x27;DataTables Responsive requires DataTables 1.10.1 or newer&#x27;;
	}

	this.s = {
		dt: new DataTable.Api( settings ),
		columns: []
	};

	// Check if responsive has already been initialised on this table
	if ( this.s.dt.settings()[0].responsive ) {
		return;
	}

	// details is an object, but for simplicity the user can give it as a string
	if ( opts &amp;&amp; typeof opts.details === &#x27;string&#x27; ) {
		opts.details = { type: opts.details };
	}

	this.c = $.extend( true, {}, Responsive.defaults, DataTable.defaults.responsive, opts );
	settings.responsive = this;
	this._constructor();
};

Responsive.prototype = {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialise the Responsive instance
	 *
	 * @private
	 */
	_constructor: function ()
	{
		var that = this;
		var dt = this.s.dt;

		dt.settings()[0]._responsive = this;

		// Use DataTables&#x27; private throttle function to avoid processor thrashing
		$(window).on( &#x27;resize.dtr orientationchange.dtr&#x27;, dt.settings()[0].oApi._fnThrottle( function () {
			that._resize();
		} ) );

		// Destroy event handler
		dt.on( &#x27;destroy.dtr&#x27;, function () {
			$(window).off( &#x27;resize.dtr orientationchange.dtr draw.dtr&#x27; );
		} );

		// Reorder the breakpoints array here in case they have been added out
		// of order
		this.c.breakpoints.sort( function (a, b) {
			return a.width &lt; b.width ? 1 :
				a.width &gt; b.width ? -1 : 0;
		} );

		// Determine which columns are already hidden, and should therefore
		// remain hidden. todo - should this be done? See thread 22677
		//
		// this.s.alwaysHidden = dt.columns(&#x27;:hidden&#x27;).indexes();

		this._classLogic();
		this._resizeAuto();

		// Details handler
		var details = this.c.details;
		if ( details.type ) {
			that._detailsInit();
			this._detailsVis();

			dt.on( &#x27;column-visibility.dtr&#x27;, function () {
				that._detailsVis();
			} );

			// Redraw the details box on each draw. This is used until
			// DataTables implements a native &#x60;updated&#x60; event for rows
			dt.on( &#x27;draw.dtr&#x27;, function () {
				dt.rows( {page: &#x27;current&#x27;} ).iterator( &#x27;row&#x27;, function ( settings, idx ) {
					var row = dt.row( idx );

					if ( row.child.isShown() ) {
						var info = that.c.details.renderer( dt, idx );
						row.child( info, &#x27;child&#x27; ).show();
					}
				} );
			} );

			$(dt.table().node()).addClass( &#x27;dtr-&#x27;+details.type );
		}

		// First pass - draw the table for the current viewport size
		this._resize();
	},


	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Calculate the visibility for the columns in a table for a given
	 * breakpoint. The result is pre-determined based on the class logic if
	 * class names are used to control all columns, but the width of the table
	 * is also used if there are columns which are to be automatically shown
	 * and hidden.
	 *
	 * @param  {string} breakpoint Breakpoint name to use for the calculation
	 * @return {array} Array of boolean values initiating the visibility of each
	 *   column.
	 *  @private
	 */
	_columnsVisiblity: function ( breakpoint )
	{
		var dt = this.s.dt;
		var columns = this.s.columns;
		var i, ien;

		// Class logic - determine which columns are in this breakpoint based
		// on the classes. If no class control (i.e. &#x60;auto&#x60;) then &#x60;-&#x60; is used
		// to indicate this to the rest of the function
		var display = $.map( columns, function ( col ) {
			return col.auto &amp;&amp; col.minWidth === null ?
				false :
				col.auto === true ?
					&#x27;-&#x27; :
					$.inArray( breakpoint, col.includeIn ) !== -1;
		} );

		// Auto column control - first pass: how much width is taken by the
		// ones that must be included from the non-auto columns
		var requiredWidth = 0;
		for ( i=0, ien=display.length ; i&lt;ien ; i++ ) {
			if ( display[i] === true ) {
				requiredWidth += columns[i].minWidth;
			}
		}

		// Second pass, use up any remaining width for other columns. For
		// scrolling tables we need to subtract the width of the scrollbar. It
		// may not be requires which makes this sub-optimal, but it would
		// require another full redraw to make complete use of those extra few
		// pixels
		var scrolling = dt.settings()[0].oScroll;
		var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
		var widthAvailable = dt.table().container().offsetWidth - bar;
		var usedWidth = widthAvailable - requiredWidth;

		// Control column needs to always be included. This makes it sub-
		// optimal in terms of using the available with, but to stop layout
		// thrashing or overflow. Also we need to account for the control column
		// width first so we know how much width is available for the other
		// columns, since the control column might not be the first one shown
		for ( i=0, ien=display.length ; i&lt;ien ; i++ ) {
			if ( columns[i].control ) {
				usedWidth -= columns[i].minWidth;
			}
		}

		// Allow columns to be shown (counting from the left) until we run out
		// of room
		var empty = false;
		for ( i=0, ien=display.length ; i&lt;ien ; i++ ) {
			if ( display[i] === &#x27;-&#x27; &amp;&amp; ! columns[i].control ) {
				// Once we&#x27;ve found a column that won&#x27;t fit we don&#x27;t let any
				// others display either, or columns might disappear in the
				// middle of the table
				if ( empty || usedWidth - columns[i].minWidth &lt; 0 ) {
					empty = true;
					display[i] = false;
				}
				else {
					display[i] = true;
				}

				usedWidth -= columns[i].minWidth;
			}
		}

		// Determine if the &#x27;control&#x27; column should be shown (if there is one).
		// This is the case when there is a hidden column (that is not the
		// control column). The two loops look inefficient here, but they are
		// trivial and will fly through. We need to know the outcome from the
		// first , before the action in the second can be taken
		var showControl = false;

		for ( i=0, ien=columns.length ; i&lt;ien ; i++ ) {
			if ( ! columns[i].control &amp;&amp; ! columns[i].never &amp;&amp; ! display[i] ) {
				showControl = true;
				break;
			}
		}

		for ( i=0, ien=columns.length ; i&lt;ien ; i++ ) {
			if ( columns[i].control ) {
				display[i] = showControl;
			}
		}

		// Finally we need to make sure that there is at least one column that
		// is visible
		if ( $.inArray( true, display ) === -1 ) {
			display[0] = true;
		}

		return display;
	},


	/**
	 * Create the internal &#x60;columns&#x60; array with information about the columns
	 * for the table. This includes determining which breakpoints the column
	 * will appear in, based upon class names in the column, which makes up the
	 * vast majority of this method.
	 *
	 * @private
	 */
	_classLogic: function ()
	{
		var that = this;
		var calc = {};
		var breakpoints = this.c.breakpoints;
		var columns = this.s.dt.columns().eq(0).map( function (i) {
			var className = this.column(i).header().className;

			return {
				className: className,
				includeIn: [],
				auto:      false,
				control:   false,
				never:     className.match(/\bnever\b/) ? true : false
			};
		} );

		// Simply add a breakpoint to &#x60;includeIn&#x60; array, ensuring that there are
		// no duplicates
		var add = function ( colIdx, name ) {
			var includeIn = columns[ colIdx ].includeIn;

			if ( $.inArray( name, includeIn ) === -1 ) {
				includeIn.push( name );
			}
		};

		var column = function ( colIdx, name, operator, matched ) {
			var size, i, ien;

			if ( ! operator ) {
				columns[ colIdx ].includeIn.push( name );
			}
			else if ( operator === &#x27;max-&#x27; ) {
				// Add this breakpoint and all smaller
				size = that._find( name ).width;

				for ( i=0, ien=breakpoints.length ; i&lt;ien ; i++ ) {
					if ( breakpoints[i].width &lt;= size ) {
						add( colIdx, breakpoints[i].name );
					}
				}
			}
			else if ( operator === &#x27;min-&#x27; ) {
				// Add this breakpoint and all larger
				size = that._find( name ).width;

				for ( i=0, ien=breakpoints.length ; i&lt;ien ; i++ ) {
					if ( breakpoints[i].width &gt;= size ) {
						add( colIdx, breakpoints[i].name );
					}
				}
			}
			else if ( operator === &#x27;not-&#x27; ) {
				// Add all but this breakpoint (xxx need extra information)

				for ( i=0, ien=breakpoints.length ; i&lt;ien ; i++ ) {
					if ( breakpoints[i].name.indexOf( matched ) === -1 ) {
						add( colIdx, breakpoints[i].name );
					}
				}
			}
		};

		// Loop over each column and determine if it has a responsive control
		// class
		columns.each( function ( col, i ) {
			var classNames = col.className.split(&#x27; &#x27;);
			var hasClass = false;

			// Split the class name up so multiple rules can be applied if needed
			for ( var k=0, ken=classNames.length ; k&lt;ken ; k++ ) {
				var className = $.trim( classNames[k] );

				if ( className === &#x27;all&#x27; ) {
					// Include in all
					hasClass = true;
					col.includeIn = $.map( breakpoints, function (a) {
						return a.name;
					} );
					return;
				}
				else if ( className === &#x27;none&#x27; || className === &#x27;never&#x27; ) {
					// Include in none (default) and no auto
					hasClass = true;
					return;
				}
				else if ( className === &#x27;control&#x27; ) {
					// Special column that is only visible, when one of the other
					// columns is hidden. This is used for the details control
					hasClass = true;
					col.control = true;
					return;
				}

				$.each( breakpoints, function ( j, breakpoint ) {
					// Does this column have a class that matches this breakpoint?
					var brokenPoint = breakpoint.name.split(&#x27;-&#x27;);
					var re = new RegExp( &#x27;(min\\-|max\\-|not\\-)?(&#x27;+brokenPoint[0]+&#x27;)(\\-[_a-zA-Z0-9])?&#x27; );
					var match = className.match( re );

					if ( match ) {
						hasClass = true;

						if ( match[2] === brokenPoint[0] &amp;&amp; match[3] === &#x27;-&#x27;+brokenPoint[1] ) {
							// Class name matches breakpoint name fully
							column( i, breakpoint.name, match[1], match[2]+match[3] );
						}
						else if ( match[2] === brokenPoint[0] &amp;&amp; ! match[3] ) {
							// Class name matched primary breakpoint name with no qualifier
							column( i, breakpoint.name, match[1], match[2] );
						}
					}
				} );
			}

			// If there was no control class, then automatic sizing is used
			if ( ! hasClass ) {
				col.auto = true;
			}
		} );

		this.s.columns = columns;
	},


	/**
	 * Initialisation for the details handler
	 *
	 * @private
	 */
	_detailsInit: function ()
	{
		var that    = this;
		var dt      = this.s.dt;
		var details = this.c.details;

		// The inline type always uses the first child as the target
		if ( details.type === &#x27;inline&#x27; ) {
			details.target = &#x27;td:first-child&#x27;;
		}

		// type.target can be a string jQuery selector or a column index
		var target   = details.target;
		var selector = typeof target === &#x27;string&#x27; ? target : &#x27;td&#x27;;

		// Click handler to show / hide the details rows when they are available
		$( dt.table().body() ).on( &#x27;click&#x27;, selector, function (e) {
			// If the table is not collapsed (i.e. there is no hidden columns)
			// then take no action
			if ( ! $(dt.table().node()).hasClass(&#x27;collapsed&#x27; ) ) {
				return;
			}

			// Check that the row is actually a DataTable&#x27;s controlled node
			if ( ! dt.row( $(this).closest(&#x27;tr&#x27;) ).length ) {
				return;
			}

			// For column index, we determine if we should act or not in the
			// handler - otherwise it is already okay
			if ( typeof target === &#x27;number&#x27; ) {
				var targetIdx = target &lt; 0 ?
					dt.columns().eq(0).length + target :
					target;

				if ( dt.cell( this ).index().column !== targetIdx ) {
					return;
				}
			}

			// $().closest() includes itself in its check
			var row = dt.row( $(this).closest(&#x27;tr&#x27;) );

			if ( row.child.isShown() ) {
				row.child( false );
				$( row.node() ).removeClass( &#x27;parent&#x27; );
			}
			else {
				var info = that.c.details.renderer( dt, row[0] );
				row.child( info, &#x27;child&#x27; ).show();
				$( row.node() ).addClass( &#x27;parent&#x27; );
			}
		} );
	},


	/**
	 * Update the child rows in the table whenever the column visibility changes
	 *
	 * @private
	 */
	_detailsVis: function ()
	{
		var that = this;
		var dt = this.s.dt;

		// Find how many columns are hidden
		var hiddenColumns = dt.columns().indexes().filter( function ( idx ) {
			var col = dt.column( idx );

			if ( col.visible() ) {
				return null;
			}

			// Only counts as hidden if it doesn&#x27;t have the &#x60;never&#x60; class
			return $( col.header() ).hasClass( &#x27;never&#x27; ) ? null : idx;
		} );
		var haveHidden = true;

		if ( hiddenColumns.length === 0 || ( hiddenColumns.length === 1 &amp;&amp; this.s.columns[ hiddenColumns[0] ].control ) ) {
			haveHidden = false;
		}

		if ( haveHidden ) {
			// Show all existing child rows
			dt.rows( { page: &#x27;current&#x27; } ).eq(0).each( function (idx) {
				var row = dt.row( idx );

				if ( row.child() ) {
					var info = that.c.details.renderer( dt, row[0] );

					// The renderer can return false to have no child row
					if ( info === false ) {
						row.child.hide();
					}
					else {
						row.child( info, &#x27;child&#x27; ).show();
					}
				}
			} );
		}
		else {
			// Hide all existing child rows
			dt.rows( { page: &#x27;current&#x27; } ).eq(0).each( function (idx) {
				dt.row( idx ).child.hide();
			} );
		}
	},


	/**
	 * Find a breakpoint object from a name
	 * @param  {string} name Breakpoint name to find
	 * @return {object}      Breakpoint description object
	 */
	_find: function ( name )
	{
		var breakpoints = this.c.breakpoints;

		for ( var i=0, ien=breakpoints.length ; i&lt;ien ; i++ ) {
			if ( breakpoints[i].name === name ) {
				return breakpoints[i];
			}
		}
	},


	/**
	 * Alter the table display for a resized viewport. This involves first
	 * determining what breakpoint the window currently is in, getting the
	 * column visibilities to apply and then setting them.
	 *
	 * @private
	 */
	_resize: function ()
	{
		var dt = this.s.dt;
		var width = $(window).width();
		var breakpoints = this.c.breakpoints;
		var breakpoint = breakpoints[0].name;
		var columns = this.s.columns;
		var i, ien;

		// Determine what breakpoint we are currently at
		for ( i=breakpoints.length-1 ; i&gt;=0 ; i-- ) {
			if ( width &lt;= breakpoints[i].width ) {
				breakpoint = breakpoints[i].name;
				break;
			}
		}

		// Show the columns for that break point
		var columnsVis = this._columnsVisiblity( breakpoint );

		// Set the class before the column visibility is changed so event
		// listeners know what the state is. Need to determine if there are
		// any columns that are not visible but can be shown
		var collapsedClass = false;
		for ( i=0, ien=columns.length ; i&lt;ien ; i++ ) {
			if ( columnsVis[i] === false &amp;&amp; ! columns[i].never ) {
				collapsedClass = true;
				break;
			}
		}

		$( dt.table().node() ).toggleClass(&#x27;collapsed&#x27;, collapsedClass );

		dt.columns().eq(0).each( function ( colIdx, i ) {
			dt.column( colIdx ).visible( columnsVis[i] );
		} );
	},


	/**
	 * Determine the width of each column in the table so the auto column hiding
	 * has that information to work with. This method is never going to be 100%
	 * perfect since column widths can change slightly per page, but without
	 * seriously compromising performance this is quite effective.
	 *
	 * @private
	 */
	_resizeAuto: function ()
	{
		var dt = this.s.dt;
		var columns = this.s.columns;

		// Are we allowed to do auto sizing?
		if ( ! this.c.auto ) {
			return;
		}

		// Are there any columns that actually need auto-sizing, or do they all
		// have classes defined
		if ( $.inArray( true, $.map( columns, function (c) { return c.auto; } ) ) === -1 ) {
			return;
		}

		// Clone the table with the current data in it
		var tableWidth   = dt.table().node().offsetWidth;
		var columnWidths = dt.columns;
		var clonedTable  = dt.table().node().cloneNode( false );
		var clonedHeader = $( dt.table().header().cloneNode( false ) ).appendTo( clonedTable );
		var clonedBody   = $( dt.table().body().cloneNode( false ) ).appendTo( clonedTable );

		$( dt.table().footer() ).clone( false ).appendTo( clonedTable );

		// This is a bit slow, but we need to get a clone of each row that
		// includes all columns. As such, try to do this as little as possible.
		dt.rows( { page: &#x27;current&#x27; } ).indexes().flatten().each( function ( idx ) {
			var clone = dt.row( idx ).node().cloneNode( true );

			if ( dt.columns( &#x27;:hidden&#x27; ).flatten().length ) {
				$(clone).append( dt.cells( idx, &#x27;:hidden&#x27; ).nodes().to$().clone() );
			}

			$(clone).appendTo( clonedBody );
		} );

		var cells = dt.columns().header().to$().clone( false );
		$(&#x27;&lt;tr/&gt;&#x27;)
			.append( cells )
			.appendTo( clonedHeader );

		// In the inline case extra padding is applied to the first column to
		// give space for the show / hide icon. We need to use this in the
		// calculation
		if ( this.c.details.type === &#x27;inline&#x27; ) {
			$(clonedTable).addClass( &#x27;dtr-inline collapsed&#x27; );
		}

		var inserted = $(&#x27;&lt;div/&gt;&#x27;)
			.css( {
				width: 1,
				height: 1,
				overflow: &#x27;hidden&#x27;
			} )
			.append( clonedTable );

		// Remove columns which are not to be included
		inserted.find(&#x27;th.never, td.never&#x27;).remove();

		inserted.insertBefore( dt.table().node() );

		// The cloned header now contains the smallest that each column can be
		dt.columns().eq(0).each( function ( idx ) {
			columns[idx].minWidth = cells[ idx ].offsetWidth || 0;
		} );

		inserted.remove();
	}
};


/**
 * List of default breakpoints. Each item in the array is an object with two
 * properties:
 *
 * * &#x60;name&#x60; - the breakpoint name.
 * * &#x60;width&#x60; - the breakpoint width
 *
 * @name Responsive.breakpoints
 * @static
 */
Responsive.breakpoints = [
	{ name: &#x27;desktop&#x27;,  width: Infinity },
	{ name: &#x27;tablet-l&#x27;, width: 1024 },
	{ name: &#x27;tablet-p&#x27;, width: 768 },
	{ name: &#x27;mobile-l&#x27;, width: 480 },
	{ name: &#x27;mobile-p&#x27;, width: 320 }
];


/**
 * Responsive default settings for initialisation
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.defaults = {
	/**
	 * List of breakpoints for the instance. Note that this means that each
	 * instance can have its own breakpoints. Additionally, the breakpoints
	 * cannot be changed once an instance has been creased.
	 *
	 * @type {Array}
	 * @default Takes the value of &#x60;Responsive.breakpoints&#x60;
	 */
	breakpoints: Responsive.breakpoints,

	/**
	 * Enable / disable auto hiding calculations. It can help to increase
	 * performance slightly if you disable this option, but all columns would
	 * need to have breakpoint classes assigned to them
	 *
	 * @type {Boolean}
	 * @default  &#x60;true&#x60;
	 */
	auto: true,

	/**
	 * Details control. If given as a string value, the &#x60;type&#x60; property of the
	 * default object is set to that value, and the defaults used for the rest
	 * of the object - this is for ease of implementation.
	 *
	 * The object consists of the following properties:
	 *
	 * * &#x60;renderer&#x60; - function that is called for display of the child row data.
	 *   The default function will show the data from the hidden columns
	 * * &#x60;target&#x60; - Used as the selector for what objects to attach the child
	 *   open / close to
	 * * &#x60;type&#x60; - &#x60;false&#x60; to disable the details display, &#x60;inline&#x60; or &#x60;column&#x60;
	 *   for the two control types
	 *
	 * @type {Object|string}
	 */
	details: {
		renderer: function ( api, rowIdx ) {
			var data = api.cells( rowIdx, &#x27;:hidden&#x27; ).eq(0).map( function ( cell ) {
				var header = $( api.column( cell.column ).header() );
				var idx = api.cell( cell ).index();

				if ( header.hasClass( &#x27;control&#x27; ) || header.hasClass( &#x27;never&#x27; ) ) {
					return &#x27;&#x27;;
				}

				// Use a non-public DT API method to render the data for display
				// This needs to be updated when DT adds a suitable method for
				// this type of data retrieval
				var dtPrivate = api.settings()[0];
				var cellData = dtPrivate.oApi._fnGetCellData(
					dtPrivate, idx.row, idx.column, &#x27;display&#x27;
				);
				var title = header.text();
				if ( title ) {
					title = title + &#x27;:&#x27;;
				}

				return &#x27;&lt;li data-dtr-index=&quot;&#x27;+idx.column+&#x27;&quot;&gt;&#x27;+
						&#x27;&lt;span class=&quot;dtr-title&quot;&gt;&#x27;+
							title+
						&#x27;&lt;/span&gt; &#x27;+
						&#x27;&lt;span class=&quot;dtr-data&quot;&gt;&#x27;+
							cellData+
						&#x27;&lt;/span&gt;&#x27;+
					&#x27;&lt;/li&gt;&#x27;;
			} ).toArray().join(&#x27;&#x27;);

			return data ?
				$(&#x27;&lt;ul data-dtr-index=&quot;&#x27;+rowIdx+&#x27;&quot;/&gt;&#x27;).append( data ) :
				false;
		},

		target: 0,

		type: &#x27;inline&#x27;
	}
};


/*
 * API
 */
var Api = $.fn.dataTable.Api;

// Doesn&#x27;t do anything - work around for a bug in DT... Not documented
Api.register( &#x27;responsive()&#x27;, function () {
	return this;
} );

Api.register( &#x27;responsive.index()&#x27;, function ( li ) {
	li = $(li);

	return {
		column: li.data(&#x27;dtr-index&#x27;),
		row:    li.parent().data(&#x27;dtr-index&#x27;)
	};
} );

Api.register( &#x27;responsive.rebuild()&#x27;, function () {
	return this.iterator( &#x27;table&#x27;, function ( ctx ) {
		if ( ctx._responsive ) {
			ctx._responsive._classLogic();
		}
	} );
} );

Api.register( &#x27;responsive.recalc()&#x27;, function () {
	return this.iterator( &#x27;table&#x27;, function ( ctx ) {
		if ( ctx._responsive ) {
			ctx._responsive._resizeAuto();
			ctx._responsive._resize();
		}
	} );
} );


/**
 * Version information
 *
 * @name Responsive.version
 * @static
 */
Responsive.version = &#x27;1.0.6&#x27;;


$.fn.dataTable.Responsive = Responsive;
$.fn.DataTable.Responsive = Responsive;

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on( &#x27;init.dt.dtr&#x27;, function (e, settings, json) {
	if ( e.namespace !== &#x27;dt&#x27; ) {
		return;
	}

	if ( $(settings.nTable).hasClass( &#x27;responsive&#x27; ) ||
		 $(settings.nTable).hasClass( &#x27;dt-responsive&#x27; ) ||
		 settings.oInit.responsive ||
		 DataTable.defaults.responsive
	) {
		var init = settings.oInit.responsive;

		if ( init !== false ) {
			new Responsive( settings, $.isPlainObject( init ) ? init : {}  );
		}
	}
} );

return Responsive;
}; // /factory


// Define as an AMD module if possible
if ( typeof define === &#x27;function&#x27; &amp;&amp; define.amd ) {
	define( [&#x27;jquery&#x27;, &#x27;datatables&#x27;], factory );
}
else if ( typeof exports === &#x27;object&#x27; ) {
    // Node/CommonJS
    factory( require(&#x27;jquery&#x27;), require(&#x27;datatables&#x27;) );
}
else if ( jQuery &amp;&amp; !jQuery.fn.dataTable.Responsive ) {
	// Otherwise simply initialise as normal, stopping multiple evaluation
	factory( jQuery, jQuery.fn.dataTable );
}


})(window, document);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
