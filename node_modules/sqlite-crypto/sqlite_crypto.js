var fs = require('fs');
var sqlite3 = require('sqlite3').verbose();
var crypto = require('crypto');
var q = require("q");
var encrypted = false;
var existsSync = function(filename) {
    try {
        fs.accessSync(filename);
        return true;
    } catch(ex) {
        return false;
    }
}

/*
 * @name cryptoSQLite
 * @type OBJECT
 * @param OBJECT options
 */

function cryptoSQLite(){ }

/*
 * @name db
 * @desc Reference to SQLite3
 * @type OBJECT
 */

cryptoSQLite.prototype.db = null;

/*
 * @name config
 * @desc Configuration options for cryptoSQLite
 * @type OBJECT
 */

cryptoSQLite.prototype.config = {
    algorithm: 'aes-256-ctr',
    encrypt_offset: 700, // The time to wait before encrypting the datbase file
    file: '/db.db', //The path to a database file
    tmpfile: 'tmp_db.db',
    password: '6yhbVFT6AlSkDjFhG',
    encryptor: null,
    decryptor: null,
    verbose: false
};

/*
 * @name init
 * @desc Initializes cryptoSQLite. Checks to make sure there is a file or go with memory. Then create the SQLite3 object.
 * @type FUNCTION
 * @param OBJECT options
 * @return OBJECT cryptoSQLite
 */

cryptoSQLite.prototype.init = function(options){
    var defer = q.defer();
    /* Merging passed options with the default */
    if(options) {
        for(var p in options){
            this.config[p] = options[p];
        }
    }

    options = null; delete options;
    var self = this;
    self.config.encryptor = self.config.encryptor || function () {
        return crypto.createCipher(self.config.algorithm, self.config.password);
    }

    self.config.decryptor = self.config.decryptor || function () {
        return crypto.createDecipher(self.config.algorithm, self.config.password);
    }

    self.log(this.config, 'Configuration Settings');

    // Go on to setup the SQLite3 object
    var finish = function(){
        self.setDB().then(function(res){
            defer.resolve(res);
        });
    };
    // Make the db file if it doesn't exist
    if(this.config.file && this.config.file !== ':memory:' && !existsSync(this.config.file)){
        this.makeDbFile().then(function(){ finish(); });
    }else{
        finish();
    }

    return defer.promise;
};

/*
 * @name setDB
 * @desc Creates the reference SQLite3 object.
 * @type FUNCTION
 * @return OBJECT cryptoSQLite
 */

cryptoSQLite.prototype.setDB = function(){
    var defer = q.defer();
    var self = this;
    this.db = new sqlite3.Database(this.config.file, function(){
        self.log(this, 'Database object created');
        defer.resolve(this);
    });
    return defer.promise;
};


/*
 * @name makeDbFile
 * @desc Creates the database file if needed.
 * @type FUNCTION
 * @return OBJECT cryptoSQLite
 */

cryptoSQLite.prototype.makeDbFile = function(){
    var defer = q.defer();
    var self = this;
    fs.writeFile(self.config.file, '', function(){
        self.log('New database file created');
        defer.resolve(self);
    });
    return defer.promise;
};

/*
 * @name checkEncryption
 * @desc Checks to see if the db file is encrypted or not by getting the first few bits.
 * @type FUNCTION
 * @return OBJECT buffer
 */

cryptoSQLite.prototype.checkEncryption = function(){
    var defer = q.defer();
    var self = this;
    self.log('Checking if database file is encrypted');
    var stream = fs.createReadStream(self.config.file, {start:0,end:2});
    stream.on('readable', function(){
        defer.resolve(stream.read());
    });
    return defer.promise;
};

/*
 * @name encrypt_timer
 * @desc Timer for setting encryption flags
 * @type FUNCTION
 */

cryptoSQLite.prototype.encrypt_timer = null;

/*
 * @name set_to_encrypt
 * @desc Sets the encryption flags(if it's currently being decrypted, encrypted). If this function is called before the timer goes off, it rests the timer. This way, it prevents pointless encrypting/decrypting to save resources.
 * @type FUNCTION
 * @return VOID
 */

cryptoSQLite.prototype.set_to_encrypt = function(){
    clearTimeout(this.encrypt_timer);
    var self = this;
    self.log('Queueing database file to be encrypted in '+ self.config.encrypt_offset +' miliseconds');
    this.encrypt_timer = setTimeout(function(){
        self.encryptor();
    }, this.config.encrypt_offset);
    return;
};

/*
 * @name encryptor
 * @desc Encrypts the database file.
 * @type FUNCTION
 * @return BOOLEAN If file was successfully encrypted and written
 */

cryptoSQLite.prototype.encryptor = function(){
    var defer = q.defer();
    var self = this;
    var file_path = self.config.file;
    self.log('Begin encrypting ' + file_path);
    var rStream = fs.createReadStream(file_path);
    var wStream = fs.createWriteStream(self.config.tmpfile);
    var crypt_proccesor = self.config.encryptor();
    var stream = rStream.pipe(crypt_proccesor).pipe(wStream);
    stream.on('close', function(){
        //delete the original and replace it with the encrypted one
        fs.unlink('/'+file_path, function(){
            fs.rename(self.config.tmpfile, file_path, function(){
                self.log('End encrypting ' + file_path);
                defer.resolve(true);
            });
        });
    });
    return defer.promise;
};

cryptoSQLite.prototype.decryptor = function(){
    var defer = q.defer();
    var self = this;
    var file_path = self.config.file;
    var rStream = fs.createReadStream(file_path);
    var wStream = fs.createWriteStream(self.config.tmpfile);
    var crypt_proccesor = self.config.decryptor();
    var stream = rStream.pipe(crypt_proccesor).pipe(wStream);
    stream.on('close', function(){
        fs.unlink('/'+file_path, function(){
            fs.rename(self.config.tmpfile, file_path, function(){
                /* Need to reset the db, otherwise you get Error: SQLITE_NOTADB: file is encrypted or is not a database] errno: 26, code: 'SQLITE_NOTADB' */
                self.setDB().then(function(db){
                    self.log('Finished decrypting database file and restarting SQLite call');
                    defer.resolve(true);
                });
            });
        });
    });
    return defer.promise;
};

/*
 * @name run
 * @desc Executes SQL queries
 * @type FUNCTION
 * @param OBJECT options
 * @return ARRAY errors, docs
 */

cryptoSQLite.prototype.run = function(options){
    var defer = q.defer();
    var self = this;
    self.log(options.sql, 'Begin SQLite call - method: '+ options.method);
    var go = function(){
        var file_path = self.config.file;
        self.checkEncryption().then(function(str){
            try{ str = str.toString('utf8');}
            catch(e){}

            if(str == 'SQL' || str == null || str == ''){
                self.log('Database file is not encrypted, continue SQLite call');
                var method = (options.method)? options.method : 'run';
                var sql = options.sql;
                self.db[method](sql, function(err,doc){
                    self.set_to_encrypt();
                    if (err) {
                        self.log(err, 'SQLite error:');
                        defer.reject(err);
                    } else {
                        self.log(doc, 'SQLite success, results:');
                        defer.resolve(doc);
                    }
                });
            }else{
                self.log('Database file is encrypted, start decryption');
                //If the file is encrypted, decrypt it then cycle back
                self.decryptor().then(function(){
                    go();
                });
            }
        });
    }
    go();
    return defer.promise;
};

/*
 * @name log
 * @desc Simple console.log formatter
 * @type FUNCTION
 * @param MIXED data
 * @param STRING name - the text you want above the data.
 * @return ARRAY errors, docs
 */

cryptoSQLite.prototype.log = function(data, name){
    var self = this;
    if(self.config.verbose){
        console.log('--------------------------------------');
        console.log(' ');
        console.log(' ');
        if(name) console.log(name);
        console.log(' ');
        console.log(data);
        console.log(' ');
        console.log('---------------------------------------');
    }
};

cryptoSQLite.prototype.something = function(){
    readstream
};

module.exports = new cryptoSQLite();
